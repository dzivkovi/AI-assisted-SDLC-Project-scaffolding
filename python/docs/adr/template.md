# [Short Title of Solved Problem and Solution]

> **Why ADRs Matter in AI-Assisted Development**
>
> In AI-assisted workflows, decisions evolve rapidly and context windows are limited. ADRs serve as persistent memory for both humans and AI agents, capturing not just *what* you chose, but *why* you rejected alternatives. This prevents re-litigating settled decisions and provides crucial context when requirements change or new team members (human or AI) join the project.
>
> **Key Benefits:**
> - **AI Context Efficiency:** Concise decision summaries fit in AI context windows
> - **Prevent Re-Work:** Documented alternatives show what was already tried
> - **Team Onboarding:** New developers understand architectural choices quickly
> - **Audit Trail:** Track how constraints and requirements shaped decisions
>
> **Learn More:**
> - [AWS: ADR Process Guide](https://docs.aws.amazon.com/prescriptive-guidance/latest/architectural-decision-records/adr-process.html)
> - [Refactoring.fm: Engineering Docs in AI Era](https://refactoring.fm/p/how-engineering-docs-change-with)
> - [Salesforce: Human-Led, AI-Powered Decisions](https://www.salesforce.com/blog/architectural-decisions-human-led-ai-powered-approach/)

---

**Status:** [proposed | rejected | accepted | deprecated | superseded by [ADR-0005](0005-example.md)]

**Date:** YYYY-MM-DD

**Decision Maker(s):** [Name(s)]

## Context

What is the issue that we're seeing that is motivating this decision or change?

Include relevant background information:
- What problem are we solving?
- What constraints do we face?
- What requirements must be met?
- What is the current situation?

## Decision

What is the change that we're proposing and/or doing?

Be specific and concrete:
- What technology/approach are we using?
- What configuration or parameters?
- What scope (production, development, testing)?

## Consequences

What becomes easier or more difficult to do because of this change?

### Positive Consequences

- [e.g., improvement of quality attribute, follows some principle, ...]
- [e.g., enables future capability, reduces complexity, ...]
- [e.g., better performance, improved developer experience, ...]

### Negative Consequences

- [e.g., compromising quality attribute, violates some principle, ...]
- [e.g., increased maintenance burden, steeper learning curve, ...]
- [e.g., vendor lock-in, higher costs, ...]

## Alternatives Considered

What other options were evaluated?

For each alternative:
- **Option:** Brief description
- **Pros:** Why it was attractive
- **Cons:** Why it was rejected
- **Status:** rejected | deferred | out-of-scope

## Research References

Link to detailed research and supporting materials:
- [Internal research documents in /work/ directory]
- [Benchmark data, performance tests]
- [External articles, documentation, papers]
- [Community discussions, issue trackers]

## Notes

(Optional) Any additional context, future considerations, or follow-up items.
